var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// package.json
var require_package = __commonJS({
  "package.json"(exports, module2) {
    module2.exports = {
      name: "@loglib/tracker",
      version: "0.8.0",
      description: "A simple tracker for loglib",
      main: "./dist/index.js",
      packageManager: "pnpm@7.9.5",
      scripts: {
        test: "vitest",
        dev: "rm -rf /dist & tsup --watch",
        build: "rm -rf /dist & tsup",
        lint: "rome check ."
      },
      exports: {
        ".": {
          browser: "./dist/index.js",
          import: "./dist/index.js",
          require: "./dist/index.cjs"
        },
        "./react": {
          browser: "./dist/react/index.js",
          import: "./dist/react/index.js",
          require: "./dist/react/index.cjs"
        }
      },
      typesVersions: {
        "*": {
          "*": [
            "dist/index.d.ts"
          ],
          react: [
            "dist/react/index.d.ts"
          ]
        }
      },
      types: "dist/index.d.ts",
      keywords: [
        "loglib",
        "event tracker",
        "web analytics",
        "analytics"
      ],
      author: "",
      license: "MIT",
      files: [
        "dist",
        "package.json",
        "LICENSE",
        "README.md"
      ],
      devDependencies: {
        "@changesets/changelog-git": "^0.1.14",
        "@changesets/changelog-github": "^0.4.8",
        "@changesets/cli": "^2.26.1",
        "@loglib/types": "0.0.1",
        "@types/jest": "^29.5.1",
        "@types/node": "^18.15.13",
        "@types/react": "^18.2.0",
        "@types/testing-library__jest-dom": "^5.14.5",
        "@vitest/browser": "^0.31.1",
        "happy-dom": "^9.20.3",
        react: "^18.2.0",
        sinon: "^15.0.4",
        terser: "^5.17.3",
        tsup: "^6.7.0",
        typescript: "^5.1.6",
        vitest: "^0.31.0",
        webdriverio: "^8.10.5"
      },
      peerDependencies: {
        react: "^16.8||^17||^18"
      },
      dependencies: {
        "web-vitals": "^3.4.0"
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  loglib: () => loglib
});
module.exports = __toCommonJS(src_exports);

// src/utils/util.ts
function getVisitorId() {
  const getId = () => localStorage.getItem("loglib-id");
  if (window.llc.consent === "denied" && !getId()) {
    return "";
  } else {
    window.llc.consent = "granted";
    if (!getId()) {
      window.localStorage.setItem("loglib-id", guid());
    }
    return getId();
  }
}
function flush() {
  window.lli.eventsBank = [];
}
function checkDoNotTrackClass(e) {
  const target = e.target;
  if (target.hasAttribute("doNotTrack")) {
    return true;
  }
  return false;
}
var getUrlParams = () => {
  const urlSearchParams = new URLSearchParams(window.location.search);
  return Object.fromEntries(urlSearchParams.entries());
};
function isDevelopment() {
  return window.llc.env === "dev";
}
function guid() {
  let d = (/* @__PURE__ */ new Date()).getTime();
  const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === "x" ? r : r & 3 | 8).toString(16);
  });
  return uuid;
}
function detectEnvironment() {
  try {
    const env = process.env.NODE_ENV;
    if (env === "development" || env === "test") {
      return "dev";
    }
  } catch {
    return "prod";
  }
  return "prod";
}
var getPath = (url) => {
  if (url.substring(0, 4) === "http") {
    return `/${url.split("/").splice(3).join("/")}`;
  }
  return url;
};
var hook = (_this, method, callback) => {
  const orig = _this[method];
  return (...args) => {
    callback(...args);
    return orig.apply(_this, args);
  };
};
var clearIntervals = () => {
  window.lli.intervals.forEach((intervalId) => clearInterval(intervalId));
};
var addInterval = (interval) => {
  window.lli.intervals.push(interval);
};
function q(e) {
  window.lli.eventsBank.push(e);
}
function getUrl() {
  if (typeof process === "undefined") {
    return "https://api.loglib.io";
  }
  if (process.env.NEXT_PUBLIC_LOGLIB_URL || process.env.LOGLIB_URL) {
    const url = process.env.NEXT_PUBLIC_LOGLIB_URL ?? process.env.LOGLIB_URL;
    return `${url}/api/loglib`;
  }
  return "https://api.loglib.io";
}
var parseHost = (url) => {
  if (url === "https://loglib.io" || url === "https://www.loglib.io") {
    return "https://loglib.io/api/loglib";
  } else {
    return url;
  }
};
var getSessionDuration = () => {
  const startTime = sessionStorage.getItem("loglib-session-start-time");
  if (startTime) {
    return (Date.now() - parseInt(startTime)) / 1e3;
  }
  return 0;
};

// src/handlers/clickHandler.ts
var clickHandler = (e) => {
  const target = e.target;
  const payload = {};
  if (checkDoNotTrackClass(e))
    return;
  if (!window.llc.autoTrack)
    return;
  if (typeof target.onclick !== "function" && target.nodeName !== "BUTTON") {
    return;
  }
  q({
    id: guid(),
    eventName: target.textContent?.replace(/[\W_]+/g, "") ?? "",
    eventType: "click",
    page: location.pathname,
    payload
  });
};

// src/utils/logger.ts
var Logger = (debug) => {
  return {
    log(...args) {
      debug && console.log(...args);
    },
    error(...args) {
      debug && console.error(...args);
    }
  };
};

// src/server.ts
function sendPageView(currentRef, currentUrl) {
  const dataToSend = {
    id: window.lli.pageId,
    path: "/hits",
    currentPath: currentUrl,
    referrerPath: currentRef,
    referrerDomain: document.referrer,
    websiteId: window.llc.id,
    host: location.href,
    sdkVersion: window.lli.sdkVersion,
    visitorId: getVisitorId(),
    sessionId: window.lli.sessionId,
    screenWidth: window.screen.width,
    language: navigator.language,
    queryParams: getUrlParams(),
    pageId: window.lli.pageId,
    duration: (Date.now() - window.lli.timeOnPage) / 1e3
  };
  send(dataToSend);
}
function sendEvents() {
  if (window.lli.eventsBank.length) {
    const eventToSend = {
      path: "/event",
      events: window.lli.eventsBank,
      websiteId: window.llc.id,
      visitorId: getVisitorId(),
      sessionId: window.lli.sessionId,
      screenWidth: window.screen.width,
      language: navigator.language ?? "en"
    };
    send(eventToSend, flush);
  }
}
function sendVisitor(payload) {
  const visitorToSend = {
    path: "/visitor",
    data: payload,
    websiteId: window.llc.id,
    visitorId: getVisitorId(),
    sessionId: window.lli.sessionId,
    pageId: window.lli.pageId,
    duration: getSessionDuration()
  };
  send(visitorToSend);
}
async function send(data, onSuccess, onError, path) {
  const logger = Logger(window.llc.debug);
  const url = path ? window.llc.host + path : window.llc.host;
  if (!data || Array.isArray(data) && data.length === 0) {
    logger.log("skipping empty request...");
    return;
  }
  if (isDevelopment()) {
    logger.log("skipping development logs...");
    return;
  }
  logger.log("sending...", data);
  let retryCount = 0;
  const maxRetries = 3;
  async function sendRequest(host) {
    try {
      if (!window.llc.useBeacon) {
        await fetch(host, {
          body: JSON.stringify(data),
          method: "POST",
          keepalive: true,
          headers: {
            "Content-Type": "application/json"
          }
        }).then(() => onSuccess?.());
      } else {
        navigator.sendBeacon(host, JSON.stringify(data));
        onSuccess?.();
      }
    } catch {
      const xhr = new XMLHttpRequest();
      xhr.open("POST", host);
      xhr.setRequestHeader("Content-Type", "text/plain");
      xhr.onload = async () => {
        if (xhr.status === 200) {
          onSuccess?.();
        } else {
          await retry();
        }
        logger.error(xhr.statusText);
      };
      xhr.onerror = async () => {
        onError?.();
        await retry();
        logger.error("Couldn't send request to the server. See the XHR error.");
      };
      xhr.send(JSON.stringify(data));
    }
  }
  async function retry() {
    if (retryCount < maxRetries) {
      retryCount++;
      logger.log(`Retrying request. Attempt ${retryCount} of ${maxRetries}...`);
      await new Promise((resolve) => setTimeout(resolve, 1e3 * retryCount));
    } else {
      logger.error("Request failed after multiple retries.");
    }
  }
  if (Array.isArray(url)) {
    for (const host of url) {
      await sendRequest(host);
    }
  } else {
    await sendRequest(url);
  }
}

// src/vitals.ts
var import_attribution = require("web-vitals/attribution");
function recordWebVitals() {
  const queue = window.lli.vitalQueue;
  function addToQueue(metric) {
    const data = {
      visitorId: getVisitorId(),
      sessionId: window.lli.sessionId,
      sdkVersion: window.lli.sdkVersion,
      screenWidth: window.screen.width,
      language: navigator.language,
      queryParams: getUrlParams(),
      currentPath: window.lli.currentUrl,
      id: metric.id,
      delta: metric.delta,
      value: metric.value,
      name: metric.name,
      rating: metric.rating,
      navigationType: metric.navigationType,
      websiteId: window.llc.id
    };
    queue.add(data);
  }
  (0, import_attribution.onCLS)(addToQueue);
  (0, import_attribution.onFCP)(addToQueue);
  (0, import_attribution.onFID)(addToQueue);
  (0, import_attribution.onINP)(addToQueue);
  (0, import_attribution.onTTFB)(addToQueue);
  (0, import_attribution.onLCP)(addToQueue);
}
function flushVitalQueue() {
  const queue = window.lli.vitalQueue;
  if (queue.size > 0) {
    send([...queue], void 0, void 0, "/vitals");
    queue.clear();
  }
}

// src/record.ts
function record(config) {
  const defaultConfig = {
    id: "",
    debug: false,
    autoTrack: false,
    env: "auto",
    postInterval: 5,
    host: getUrl(),
    consent: "denied",
    webVitals: true,
    pageAnalytics: true,
    customEvents: true
  };
  if (config?.host) {
    if (Array.isArray(config.host)) {
      config.host = config.host.map((host) => parseHost(host));
    } else {
      config.host = parseHost(config.host);
    }
  }
  window.llc = config ? { ...defaultConfig, ...config } : defaultConfig;
  const now = Date.now();
  const packageJson = require_package();
  window.lli = {
    eventsBank: [],
    vitalQueue: /* @__PURE__ */ new Set(),
    startTime: now,
    currentUrl: `${location.pathname}${location.search}`,
    currentRef: document.referrer,
    timeOnPage: now,
    sessionId: guid(),
    pageId: guid(),
    intervals: [],
    sdkVersion: packageJson.version
  };
  const logger = Logger(window.llc.debug);
  logger.log("start recording...", window.llc);
  if (window.llc.env === "auto") {
    const env = detectEnvironment();
    window.llc.env = env;
  }
  if (window.llc.autoTrack) {
    window.addEventListener("click", clickHandler);
  }
  if (window.llc.webVitals) {
    recordWebVitals();
    const eventsInterval = setInterval(() => {
      flushVitalQueue();
    }, window.llc.postInterval * 1e3);
    addInterval(eventsInterval);
    sessionEndHandler(flushVitalQueue);
  }
  if (window.llc.customEvents) {
    const eventsInterval = setInterval(() => {
      sendEvents();
    }, window.llc.postInterval * 1e3);
    addInterval(eventsInterval);
    sessionEndHandler(sendEvents);
  }
  if (window.llc.pageAnalytics) {
    history.pushState = hook(history, "pushState", navigationHandler);
    history.replaceState = hook(history, "replaceState", navigationHandler);
    const currentRef = window.lli.currentRef;
    const currentUrl = window.lli.currentUrl;
    sessionEndHandler(() => sendPageView(currentRef, currentUrl));
  }
}
var navigationHandler = (_, __, url) => {
  if (!url)
    return;
  const currentRef = window.lli.currentRef;
  const currentUrl = window.lli.currentUrl;
  window.lli.currentRef = window.lli.currentUrl;
  window.lli.currentUrl = getPath(url.toString());
  if (currentUrl !== currentRef) {
    sendPageView(currentUrl, currentRef);
    sendEvents();
    window.lli.pageId = guid();
    window.lli.timeOnPage = Date.now();
  }
};
var sessionEndHandler = async (fn) => {
  document.onvisibilitychange = () => {
    if (document.visibilityState === "hidden") {
      fn();
      sendEvents();
      clearIntervals();
    } else {
      if (window.llc) {
        record(window.llc);
      }
    }
  };
};

// src/methods.ts
var track = (name, payload = {}) => {
  const event = {
    id: guid(),
    eventName: name,
    eventType: "manual",
    payload,
    page: window.location.pathname,
    referrerPath: window.lli.currentUrl,
    referrerDomain: window.lli.currentRef,
    duration: getSessionDuration(),
    pageId: window.lli.pageId,
    queryParams: getUrlParams()
  };
  window.llc.customEvents && q(event);
};
var identify = (payload) => {
  window.llc.consent === "granted" && sendVisitor(payload);
};
var setConsent = (concent) => {
  window.llc.consent = concent;
  sendVisitor({ concent });
};

// src/lib.ts
var loglib = {
  record,
  track,
  identify,
  setConsent
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  loglib
});
//# sourceMappingURL=index.js.map